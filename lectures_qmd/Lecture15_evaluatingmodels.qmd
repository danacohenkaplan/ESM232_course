---
title: "Lecture15_evaluatingmodels"
format: html
editor: visual
---

## 

## NSE (Nash-Sutcliffe Efficiency)

``` r
nse = function(m, o) {
  err = m - o
  meanobs = mean(o)
  mse = sum(err^2)
  ovar = sum((o - meanobs)^2)
  return(1 - mse / ovar)
}
```

------------------------------------------------------------------------

## Percent Error

``` r
relerr = function(m, o) {
  err = m - o
  meanobs = mean(o)
  return(mean(err) / meanobs)
}
```

------------------------------------------------------------------------

## Soft Metrics: Fuzzy Evaluation

-   Handle uncertainty/imprecise data
-   Fuzzy membership functions used in calibration

------------------------------------------------------------------------

## Combining Metrics

-   Normalize metrics (0-1)
-   Make all increase with performance
-   Weighted sum or multiplicative approach

------------------------------------------------------------------------

## Combined Performance

``` r
cper = function(m, o, weight.nse = 0.5, weight.relerr = 0.5) {
  nse = max(nse(m, o), 0)
  rel.err = relerr(m, o)
  merr = 1.0 - min(1.0, abs(rel.err) / max(abs(rel.err)))
  return(weight.nse * nse + weight.relerr * merr)
}
```

------------------------------------------------------------------------

## Calibration and Optimization

-   Generate parameter sets (e.g., LHS)
-   Compute metrics for each
-   Define acceptable thresholds
-   Use optimization or GLUE

------------------------------------------------------------------------

## Yield Model Example

``` r
compute_yield = function(T, P, irr, crop.pars) {
  with(as.list(crop.pars), {
    nyears = length(T)
    irr.peryear = rep(irr, nyears)
    water.input = P + irr.peryear
    yield = ifelse(water.input < max.water,
      tp * water.input - ts * abs(T - Topt) + base.yield,
      tp * max.water - ts * abs(T - Topt) + base.yield)
    return(pmax(yield, 0))
  })
}
```

------------------------------------------------------------------------

## Equifinality

-   Many parameter sets yield similar performance
-   Limits confidence in "best" calibration

------------------------------------------------------------------------

## GLUE Approach

-   Reject poor performers
-   Retain acceptable sets
-   Use ensemble to represent uncertainty

------------------------------------------------------------------------

## Model Averaging

-   Weighted average of outputs by performance
-   Produces MWE (Mean Weighted Estimate)

------------------------------------------------------------------------

## Summary

-   Choose models that are both **appropriate** and **good enough**
-   Validate using multiple methods
-   Quantify and communicate uncertainty
-   Consider equifinality in interpretation

Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see <https://quarto.org>.

## Running Code

When you click the **Render** button a document will be generated that includes both content and the output of embedded code. You can embed code like this:

```{r}
1 + 1
```

You can add options to executable code like this

```{r}
#| echo: false
2 * 2
```

The `echo: false` option disables the printing of code (only output is displayed).

## NSE (Nash-Sutcliffe Efficiency)

``` r
nse = function(m, o) {
  err = m - o
  meanobs = mean(o)
  mse = sum(err^2)
  ovar = sum((o - meanobs)^2)
  return(1 - mse / ovar)
}
```

------------------------------------------------------------------------

## Percent Error

``` r
relerr = function(m, o) {
  err = m - o
  meanobs = mean(o)
  return(mean(err) / meanobs)
}
```

------------------------------------------------------------------------

## Soft Metrics: Fuzzy Evaluation

-   Handle uncertainty/imprecise data
-   Fuzzy membership functions used in calibration

------------------------------------------------------------------------

## Combining Metrics

-   Normalize metrics (0-1)
-   Make all increase with performance
-   Weighted sum or multiplicative approach

------------------------------------------------------------------------

## Combined Performance

``` r
cper = function(m, o, weight.nse = 0.5, weight.relerr = 0.5) {
  nse = max(nse(m, o), 0)
  rel.err = relerr(m, o)
  merr = 1.0 - min(1.0, abs(rel.err) / max(abs(rel.err)))
  return(weight.nse * nse + weight.relerr * merr)
}
```

------------------------------------------------------------------------

## Calibration and Optimization

-   Generate parameter sets (e.g., LHS)
-   Compute metrics for each
-   Define acceptable thresholds
-   Use optimization or GLUE

------------------------------------------------------------------------

## Yield Model Example

``` r
compute_yield = function(T, P, irr, crop.pars) {
  with(as.list(crop.pars), {
    nyears = length(T)
    irr.peryear = rep(irr, nyears)
    water.input = P + irr.peryear
    yield = ifelse(water.input < max.water,
      tp * water.input - ts * abs(T - Topt) + base.yield,
      tp * max.water - ts * abs(T - Topt) + base.yield)
    return(pmax(yield, 0))
  })
}
```

------------------------------------------------------------------------

## Equifinality

-   Many parameter sets yield similar performance
-   Limits confidence in "best" calibration

------------------------------------------------------------------------

## GLUE Approach

-   Reject poor performers
-   Retain acceptable sets
-   Use ensemble to represent uncertainty

------------------------------------------------------------------------

## Model Averaging

-   Weighted average of outputs by performance
-   Produces MWE (Mean Weighted Estimate)

------------------------------------------------------------------------

## Summary

-   Choose models that are both **appropriate** and **good enough**
-   Validate using multiple methods
-   Quantify and communicate uncertainty
-   Consider equifinality in interpretation
